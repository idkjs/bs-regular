// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Cn = require("re-classnames/src/Cn.bs.js");
var Css = require("bs-css/src/Css.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Colors$ReactHooksTemplate = require("../theme/Colors.bs.js");
var TextInput$ReactHooksTemplate = require("./TextInput.bs.js");
var ContextLayer$ReactHooksTemplate = require("../layer/ContextLayer.bs.js");

var optionsLayer = Css.style(/* :: */[
      Css.border(/* `px */[
            25096,
            1
          ], /* solid */12956715, /* `hex */[
            5194459,
            Colors$ReactHooksTemplate.primary450
          ]),
      /* :: */[
        Css.maxHeight(/* `px */[
              25096,
              200
            ]),
        /* :: */[
          Css.overflow(/* auto */-1065951377),
          /* [] */0
        ]
      ]
    ]);

var option = Css.style(/* :: */[
      Css.backgroundColor(/* `hex */[
            5194459,
            Colors$ReactHooksTemplate.primary500
          ]),
      /* :: */[
        Css.borderBottom(/* `px */[
              25096,
              1
            ], /* solid */12956715, /* `hex */[
              5194459,
              Colors$ReactHooksTemplate.primary450
            ]),
        /* :: */[
          Css.padding2(/* `px */[
                25096,
                8
              ], /* `px */[
                25096,
                16
              ]),
          /* :: */[
            Css.lastChild(/* :: */[
                  Css.borderBottomStyle(/* none */-922086728),
                  /* [] */0
                ]),
            /* [] */0
          ]
        ]
      ]
    ]);

var optionSelected = Css.style(/* :: */[
      Css.backgroundColor(/* `hex */[
            5194459,
            Colors$ReactHooksTemplate.primary490
          ]),
      /* [] */0
    ]);

var optionFocused = Css.style(/* :: */[
      Css.textDecoration(/* underline */131142924),
      /* [] */0
    ]);

var Styles = /* module */[
  /* optionsLayer */optionsLayer,
  /* option */option,
  /* optionSelected */optionSelected,
  /* optionFocused */optionFocused
];

function Select$SelectOption(Props) {
  var option$1 = Props.option;
  var onClick = Props.onClick;
  var isSelected = Props.isSelected;
  var isFocused = Props.isFocused;
  var scrollToElement = Props.scrollToElement;
  var domRef = React.useRef(null);
  React.useEffect((function () {
          if (isFocused) {
            Curry._1(scrollToElement, Belt_Option.getExn(Caml_option.nullable_to_opt(domRef.current)));
          }
          return undefined;
        }), /* array */[isFocused]);
  return React.createElement("div", {
              ref: domRef,
              className: Cn.make(/* :: */[
                    option,
                    /* :: */[
                      Cn.ifTrue(optionSelected, isSelected),
                      /* :: */[
                        Cn.ifTrue(optionFocused, isFocused),
                        /* [] */0
                      ]
                    ]
                  ]),
              tabIndex: 0,
              onClick: onClick
            }, option$1[/* label */0]);
}

var SelectOption = /* module */[/* make */Select$SelectOption];

function Select$SelectOptions(Props) {
  var options = Props.options;
  var selectedOption = Props.selectedOption;
  var onSelect = Props.onSelect;
  var onMouseDown = Props.onMouseDown;
  var contextRef = Props.contextRef;
  var match = React.useState((function () {
          if (selectedOption !== undefined) {
            var index = options.indexOf(selectedOption);
            if (index !== -1) {
              return index;
            } else {
              return 0;
            }
          } else {
            return 0;
          }
        }));
  var setFocusedIndex = match[1];
  var focusedIndex = match[0];
  var onKeyPress = function (e) {
    var numOptions = options.length;
    var match = e.key;
    switch (match) {
      case "ArrowDown" : 
          Curry._1(setFocusedIndex, (function (i) {
                  return Caml_int32.mod_(i + 1 | 0, numOptions);
                }));
          e.preventDefault();
          return /* () */0;
      case "ArrowUp" : 
          Curry._1(setFocusedIndex, (function (i) {
                  return Caml_int32.mod_((i - 1 | 0) + numOptions | 0, numOptions);
                }));
          e.preventDefault();
          return /* () */0;
      case "Enter" : 
          return Curry._1(onSelect, Belt_Array.get(options, focusedIndex));
      case "Esc" : 
      case "Escape" : 
          return Curry._1(onSelect, undefined);
      default:
        return /* () */0;
    }
  };
  var onSelectRef = React.useRef(onSelect);
  React.useEffect((function () {
          onSelectRef.current = onSelect;
          return undefined;
        }), /* array */[onSelect]);
  var contextRefRef = React.useRef(contextRef);
  React.useEffect((function () {
          contextRefRef.current = contextRef;
          return undefined;
        }), /* array */[contextRef]);
  var layerRef = React.useRef(null);
  React.useEffect((function () {
          var onClick = function (e) {
            var target = e.target;
            var layerDiv = Belt_Option.getExn(Caml_option.nullable_to_opt(layerRef.current));
            var contextElement = Belt_Option.getExn(Caml_option.nullable_to_opt(contextRefRef.current.current));
            if (!layerDiv.contains(target) && !contextElement.contains(target)) {
              var onSelect = onSelectRef.current;
              return Curry._1(onSelect, undefined);
            } else {
              return 0;
            }
          };
          document.addEventListener("click", onClick);
          return (function (param) {
                    document.removeEventListener("click", onClick);
                    return /* () */0;
                  });
        }), ([]));
  var scrollToElement = React.useCallback((function (optionElement) {
          var layerDiv = Belt_Option.getExn(Caml_option.nullable_to_opt(layerRef.current));
          var layerTop = layerDiv.scrollTop | 0;
          var layerHeight = layerDiv.offsetHeight;
          var layerBottom = layerTop + layerHeight | 0;
          var optionTop = optionElement.offsetTop;
          var optionBottom = optionTop + optionElement.offsetHeight | 0;
          if (optionTop < layerTop) {
            layerDiv.scrollTop = optionTop;
            return /* () */0;
          } else if (optionBottom > layerBottom) {
            layerDiv.scrollTop = optionBottom - layerHeight | 0;
            return /* () */0;
          } else {
            return 0;
          }
        }), ([]));
  return React.createElement(ContextLayer$ReactHooksTemplate.make, {
              contextRef: contextRef,
              position: /* Bottom */1,
              children: (function (param) {
                  var inputElement = Belt_Option.getExn(Caml_option.nullable_to_opt(contextRef.current));
                  var style = {
                    width: String(inputElement.clientWidth) + "px"
                  };
                  return React.createElement("div", {
                              ref: layerRef,
                              className: optionsLayer,
                              style: style,
                              onMouseDown: onMouseDown
                            }, options.map((function (option, i) {
                                    var isSelected = selectedOption !== undefined ? selectedOption === option : false;
                                    var isFocused = focusedIndex === i;
                                    return React.createElement(Select$SelectOption, {
                                                option: option,
                                                onClick: (function (param) {
                                                    return Curry._1(onSelect, option);
                                                  }),
                                                isSelected: isSelected,
                                                isFocused: isFocused,
                                                scrollToElement: scrollToElement,
                                                key: String(i)
                                              });
                                  })));
                }),
              onKeyPress: onKeyPress
            });
}

var SelectOptions = /* module */[/* make */Select$SelectOptions];

function Select(Props) {
  var getOptions = Props.getOptions;
  var selectedOption = Props.selectedOption;
  var onChange = Props.onChange;
  var label = Props.label;
  var placeholder = Props.placeholder;
  var match = Props.withTextInput;
  var withTextInput = match !== undefined ? match : true;
  var match$1 = Props.forceOption;
  var forceOption = match$1 !== undefined ? match$1 : false;
  var inputRef = React.useRef(null);
  var match$2 = React.useState((function () {
          return "";
        }));
  var setTextValue = match$2[1];
  var textValue = match$2[0];
  var match$3 = React.useState((function () {
          return false;
        }));
  var setShowOptions = match$3[1];
  React.useEffect((function () {
          if (selectedOption !== undefined) {
            var selectedOption$1 = selectedOption;
            Curry._1(setTextValue, (function (param) {
                    return selectedOption$1[/* label */0];
                  }));
          } else {
            Curry._1(setTextValue, (function (param) {
                    return "";
                  }));
          }
          return undefined;
        }), /* array */[selectedOption]);
  var hasSelectedOption = Belt_Option.isNone(selectedOption);
  var onInputChange = React.useCallback((function (e) {
          var value = e.currentTarget.value;
          Curry._1(setTextValue, (function (param) {
                  return value;
                }));
          Curry._1(setShowOptions, (function (param) {
                  return true;
                }));
          if (!forceOption && hasSelectedOption && onChange !== undefined) {
            return Curry._1(onChange, undefined);
          } else {
            return 0;
          }
        }), /* tuple */[
        forceOption,
        hasSelectedOption,
        onChange
      ]);
  var blurTimeout = React.useRef(undefined);
  var onBlur = React.useCallback((function (param) {
          blurTimeout.current = Caml_option.some(setTimeout((function (param) {
                      if (selectedOption !== undefined) {
                        var selectedOption$1 = selectedOption;
                        Curry._1(setTextValue, (function (param) {
                                return selectedOption$1[/* label */0];
                              }));
                      }
                      return Curry._1(setShowOptions, (function (param) {
                                    return false;
                                  }));
                    }), 100));
          return /* () */0;
        }), /* array */[selectedOption]);
  var onFocus = function (param) {
    var match = blurTimeout.current;
    if (match !== undefined) {
      clearTimeout(Caml_option.valFromOption(match));
      blurTimeout.current = undefined;
    }
    return Curry._1(setShowOptions, (function (param) {
                  return true;
                }));
  };
  var onMouseDown = React.useCallback(onFocus, ([]));
  var onSelect = function (option) {
    Curry._1(setShowOptions, (function (param) {
            return false;
          }));
    if (onChange !== undefined) {
      var onChange$1 = onChange;
      if (option !== undefined) {
        return Curry._1(onChange$1, option);
      } else if (forceOption) {
        return 0;
      } else {
        return Curry._1(onChange$1, undefined);
      }
    } else {
      return /* () */0;
    }
  };
  var options = Curry._1(getOptions, textValue);
  React.useEffect((function (param) {
          if (forceOption && Belt_Option.isNone(selectedOption)) {
            var match = Belt_Array.get(options, 0);
            if (match !== undefined) {
              if (onChange !== undefined) {
                Curry._1(onChange, match);
              }
              
            }
            
          }
          return undefined;
        }), /* tuple */[
        forceOption,
        hasSelectedOption,
        onChange
      ]);
  var tmp;
  if (withTextInput) {
    var tmp$1 = {
      value: textValue,
      onChange: onInputChange,
      ref: inputRef
    };
    if (label !== undefined) {
      tmp$1.label = Caml_option.valFromOption(label);
    }
    if (placeholder !== undefined) {
      tmp$1.placeholder = Caml_option.valFromOption(placeholder);
    }
    tmp = React.createElement(TextInput$ReactHooksTemplate.make, tmp$1);
  } else {
    var tmp$2 = {
      children: selectedOption !== undefined ? selectedOption[/* label */0] : null,
      onClick: (function (param) {
          return Curry._1(setShowOptions, (function (show) {
                        return !show;
                      }));
        }),
      ref: inputRef
    };
    if (label !== undefined) {
      tmp$2.label = Caml_option.valFromOption(label);
    }
    tmp = React.createElement(TextInput$ReactHooksTemplate.$$static, tmp$2);
  }
  var tmp$3;
  if (match$3[0]) {
    var match$4 = options.length !== 0;
    tmp$3 = match$4 ? React.createElement(Select$SelectOptions, {
            options: options,
            selectedOption: selectedOption,
            onSelect: onSelect,
            onMouseDown: onMouseDown,
            contextRef: inputRef
          }) : null;
  } else {
    tmp$3 = null;
  }
  return React.createElement("div", {
              onFocus: React.useCallback(onFocus, ([])),
              onBlur: onBlur
            }, tmp, tmp$3);
}

var make = Select;

exports.Styles = Styles;
exports.SelectOption = SelectOption;
exports.SelectOptions = SelectOptions;
exports.make = make;
/* optionsLayer Not a pure module */
